buildscript {
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "https://files.minecraftforge.net/maven"
        }
        maven {
            url "https://cloudrep.veritaris.me/repos"
        }
    }
    dependencies {
        classpath("com.anatawa12.forge:ForgeGradle:1.2-1.1.+") {
            changing = true
        }
    }
}

apply plugin: "forge"
apply plugin: "java"
apply plugin: "project-report"

def projectBuildPropertiesFile = "build.properties"
def projectBuildProperties = new Properties()
file(projectBuildPropertiesFile).withInputStream { projectBuildProperties.load(it) }
project.version = projectBuildProperties.version
project.buildVersion = projectBuildProperties.buildVersion

group 'com.dreamfinity.' + { rootProject.name }
version project.version

minecraft {
    version = "1.7.10-10.13.4.1614-1.7.10"
    mappings = "stable_12"
    runDir = "run"
    replace("@version@": projectBuildProperties.version)
    replace("@debug@": projectBuildProperties.debug)
    replace("BuildController.internalBuildState()", isClientBuild)
}

sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8

runClient {
    if (project.hasProperty("appArgs")) {
        args Eval.me(appArgs)
    }
}

repositories {
    maven {
        url "https://cloudrep.veritaris.me/repos/"
        metadataSources {
            mavenPom()
            artifact()
        }
    }
    maven {
        url "https://maven.ic2.player.to"
        metadataSources {
            artifact()
        }
    }
    mavenCentral()
    maven {
        url "https://chickenbones.net/maven"
    }
}


dependencies {
    implementation "codechicken:CodeChickenCore:1.7.10-1.0.7.48:dev"
    implementation "codechicken:CodeChickenLib:1.7.10-1.1.3.141:dev"
    implementation "codechicken:NotEnoughItems:1.7.10-1.0.5.120:dev"
    implementation "net.industrial-craft:industrialcraft-2:2.2.817-experimental:api"
}

processResources {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    inputs.property "version", projectBuildProperties.version
    inputs.property "mcversion", project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {
        include "mcmod.info"
        expand "version": projectBuildProperties.version,
                "mcversion": project.minecraft.version
    }
    from(sourceSets.main.resources.srcDirs) {
        exclude "mcmod.info"
    }
}

// client-server build separation

jar {
    if (isClientBuild.toBoolean()) {
        archiveClassifier.set("client")
    } else {
        archiveClassifier.set("universal")
    }
}

tasks.register('buildClient', GradleBuild) {
    startParameter.projectProperties = ["isClientBuild": "true"]
    tasks = ["build"]
}

tasks.register('runProtectedClient', GradleBuild) {
    startParameter.projectProperties = ["isClientBuild": "true"]
    tasks = ["runClient"]
}


// Semantic versioning start
def semanticVersioning = [
        "Major"    : "Builds .jar increasing major number: major.y.z",
        "Minor"    : "Builds .jar increasing minor number: x.minor.y",
        "Patch"    : "Builds .jar increasing patch number: x.y.patch",
        "JustBuild": "Builds .jar adding \"-build-N\" suffix and increasing build number: x.y.z-build-N",
]

semanticVersioning.keySet().each { semVerType ->
    tasks.register(semVerType, WriteProperties) {
        destinationFile = file(projectBuildPropertiesFile)
        projectBuildProperties.replace(
                "buildVersion",
                semVerType.toLowerCase() == "justbuild"
                        ? "${Integer.parseInt(projectBuildProperties.buildVersion as String) + 1}"
                        : "0"
        )
        projectBuildProperties.replace("version", makeVersion(semVerType))
        properties = projectBuildProperties as Map<String, Object>
        it.group = "Semantic versioned"
        it.finalizedBy("build")
    }
}

tasks.register("TestSemVerBuilds", GradleBuild) {
    tasks = ["JustBuild", "Patch", "Minor", "Major"]
}

def makeVersion(String bumpType) {
    def prevVersion = project.version as String
    def (major, minor, patch) = prevVersion.tokenize(".") as Collection<String>
    def newVersion
    println("Old version: ${prevVersion}, old build number: ${project.buildVersion}")
    patch = patch.split("-")[0]

    switch (bumpType.toLowerCase()) {
        case "major":
            newVersion = "${Integer.parseInt(major) + 1}.0.0"
            break

        case "minor":
            newVersion = "${major}.${Integer.parseInt(minor) + 1}.0"
            break

        case "patch":
            newVersion = "${major}.${minor}.${Integer.parseInt(patch) + 1}"
            break

        default:
            newVersion = "${major}.${minor}.${patch}-build-${Integer.parseInt(project.buildVersion) + 1}"
    }

    if (bumpType in ["major", "minor", "patch"]) {
        println("Migrating from ${prevVersion} to ${newVersion}")
    } else {
        println("Building version ${newVersion}")
    }
    project.version = newVersion
    return newVersion
}
// Semantic versioning end

tasks.register("DebugBuild", GradleBuild) {
    startParameter.projectProperties = ["debug": "true"]
    tasks = ["build"]
    println("Carefully! Building with DEBUG=true")
}

tasks.register("DebugRun", GradleBuild) {
    startParameter.projectProperties = ["debug": "true"]
    tasks = ["runClient"]
    println("Running client with DEBUG=true")
}

DebugRun.finalizedBy("runCLient")
DebugBuild.finalizedBy("build")
